use snforge_std::{
    declare, spy_events, ContractClassTrait, test_address, EventSpyAssertionsTrait,
    start_cheat_caller_address, mock_call
};
use ekubo::types::keys::{PoolKey};
use ekubo::types::i129::i129;
use ekubo::types::delta::{Delta};
use ekubo::interfaces::erc20::{IERC20Dispatcher, IERC20DispatcherTrait};
use ekubo::router_lite::{RouteNode, TokenAmount, Swap};
use core::panic_with_felt252;
// `IArbitrageurDispatcher` and `IArbitrageurDispatcherTrait` are generated by compiler within the
// attribute macros `#[starknet::interface]` for `pub trait IArbitrageur<TContractState>`
// see also
// https://book.cairo-lang.org/ch13-02-anatomy-of-a-simple-contract.html#the-interface-the-contracts-blueprint
use ekubo_flash_loan::{Arbitrage, IArbitrageurDispatcher, IArbitrageurDispatcherTrait};
use starknet::{ContractAddress, contract_address_const};

fn deploy_contract(name: ByteArray) -> ContractAddress {
    let contract = declare(name).unwrap();
    let (contract_address, _) = contract.deploy(@ArrayTrait::new()).unwrap();
    contract_address
}

// if we would use the from ekubo library, then we would get an error
// "Entry point selector 0x038ad53218834f943da60c8bafd36c36692dcb35e6d76bdd93202f5c04c0baff not
// found in contract 0x0199741822c2dc722f6f605204f35e56dbc23bceed54818168c4c49e4fb8737e"
// Moreover the types for RouterNode and TokenAmount are different
// This is because the Router interface is outdated and all recent ones have separate methods
// So we can define a necessary interface here manually
// https://voyager.online/contract/0x0199741822c2dc722f6f605204f35e56dbc23bceed54818168c4c49e4fb8737e#readContract
#[starknet::interface]
pub trait IRouter<TContractState> {
    fn multihop_swap(
        ref self: TContractState, route: Array<RouteNode>, token_amount: TokenAmount
    ) -> Array<Delta>;
}

// https://docs.ekubo.org/integration-guides/reference/contract-addresses
const EKUBO_CORE_ADDRESS: felt252 =
    0x0444a09d96389aa7148f1aada508e30b71299ffe650d9c97fdaae38cb9a23384;
const EKUBO_ROUTER_ADDRESS: felt252 =
    0x0045f933adf0607292468ad1c1dedaa74d5ad166392590e72676a34d01d7b763;

fn declare_and_deploy() -> IArbitrageurDispatcher {
    // First declare and deploy a contract
    // (the name of the contract is the contract module name)
    let contract = declare("Arbitrage").unwrap();
    // deploy function accepts a snap of an array of contract arguments serialized as felt252
    let (contract_address, _) = contract.deploy(@array![EKUBO_CORE_ADDRESS]).unwrap();

    // Create a Dispatcher object that will allow interacting with the deployed contract
    IArbitrageurDispatcher { contract_address }
}

#[test]
fn test_get_owner() {
    let dispatcher = declare_and_deploy();

    // Call a view function of the contract
    let owner = dispatcher.get_owner();
    // test_address function returns the address of the current test which is a contract itself
    assert(owner == test_address(), 'owner is set');
}

#[test]
fn test_creation_event() {
    // https://foundry-rs.github.io/starknet-foundry/testing/testing-events.html#asserting-emission-with-assert_emitted-method
    let mut spy = spy_events();

    let dispatcher = declare_and_deploy();

    spy
        .assert_emitted(
            @array![
                (
                    dispatcher.contract_address,
                    Arbitrage::Event::NewBot(Arbitrage::NewBot { owner: test_address() })
                )
            ]
        );
}

#[should_panic(expected: ('Unprofitable swap',))]
#[test]
#[fork("SEPOLIA_FORK")]
fn test_empty_swap() {
    let dispatcher = declare_and_deploy();

    dispatcher.multi_multihop_swap(array![]);
}

#[test]
#[fork("SEPOLIA_FORK")]
fn test_access() {
    let dispatcher = declare_and_deploy();
    let other_address = contract_address_const::<
        0x0344c86d9d9a189cf1b616c8d3bd550bdfd3f099f4076f7e680a14d4d8981124
    >();

    // Change the caller address to another
    // https://foundry-rs.github.io/starknet-foundry/testing/using-cheatcodes.html#cheating-an-address
    // I took a real trader address from an arbitrage transaction
    // https://voyager.online/contract/0x0344c86d9d9a189cf1b616c8d3bd550bdfd3f099f4076f7e680a14d4d8981124
    start_cheat_caller_address(dispatcher.contract_address, other_address);
    assert(other_address != test_address(), 'other_address');

    assert(dispatcher.get_owner() == test_address(), 'owner is set');

    dispatcher.multi_multihop_swap(array![]);
}

#[test]
#[fork("SEPOLIA_FORK")]
fn test_fuzz_swap(mag: u128) {
    let route = array![
        RouteNode {
            pool_key: PoolKey {
                token0: contract_address_const::<
                    0x49d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7
                >(),
                token1: contract_address_const::<
                    0x53c91253bc9682c04929ca02ed00b3e423f6710d2ee7e0d5ebb06f3ecf368a8
                >(),
                fee: 0x68db8bac710cb4000000000000000, // 0.01%
                tick_spacing: 200,
                extension: contract_address_const::<0x0>()
            },
            sqrt_ratio_limit: 0x34b6ea79633d60552061b9c37d84a,
            skip_ahead: 0x0
        },
        RouteNode {
            pool_key: PoolKey {
                token0: contract_address_const::<
                    0x49d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7
                >(),
                token1: contract_address_const::<
                    0x53c91253bc9682c04929ca02ed00b3e423f6710d2ee7e0d5ebb06f3ecf368a8
                >(),
                fee: 0x20c49ba5e353f80000000000000000, // 0.05%
                tick_spacing: 1000,
                extension: contract_address_const::<0x0>()
            },
            sqrt_ratio_limit: 0x3d5cddeb5b510bc4b323fe5199050,
            skip_ahead: 0x0
        }
    ];

    let token_amount = TokenAmount {
        token: contract_address_const::<
            0x49d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7
        >(),
        amount: i129 { mag, sign: false }
    };

    let dispatcher = declare_and_deploy();

    dispatcher.multihop_swap(route, token_amount);
}

#[test]
#[fork("SEPOLIA_FORK")]
fn test_swap() {
    // test data obtained from ekubo api with
    // curl
    // 'https://sepolia-api.ekubo.org/quote/10000000000000000/0x049d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7/0x049d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7'
    // | jq {
    //     "specifiedAmount": "10000000000000000",
    //     "amount": "11678380679671722",
    //     "route": [
    //       {
    //         "pool_key": {
    //           "token0": "0x49d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7",
    //           "token1": "0x7ab0b8855a61f480b4423c46c32fa7c553f0aac3531bbddaa282d86244f7a23",
    //           "fee": "0xccccccccccccccccccccccccccccccc",
    //           "tick_spacing": 354892,
    //           "extension": "0x73ec792c33b52d5f96940c2860d512b3884f2127d25e023eb9d44a678e4b971"
    //         },
    //         "sqrt_ratio_limit": "0x1000003f7f1380b76",
    //         "skip_ahead": "0x0"
    //       },
    //       {
    //         "pool_key": {
    //           "token0": "0x49d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7",
    //           "token1": "0x7ab0b8855a61f480b4423c46c32fa7c553f0aac3531bbddaa282d86244f7a23",
    //           "fee": "0x20c49ba5e353f80000000000000000",
    //           "tick_spacing": 354892,
    //           "extension": "0x73ec792c33b52d5f96940c2860d512b3884f2127d25e023eb9d44a678e4b971"
    //         },
    //         "sqrt_ratio_limit": "0x7ea4d9526482a9577ead999cd4fa76f2ba8dfdca5b3f2f",
    //         "skip_ahead": "0x0"
    //       }
    //     ]
    // }
    let first_node = RouteNode {
        pool_key: PoolKey {
            // a base token ETH, the denominator
            token0: contract_address_const::<
                0x49d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7
            >(),
            // a quote token USDC, the numerator
            token1: contract_address_const::<
                0x7ab0b8855a61f480b4423c46c32fa7c553f0aac3531bbddaa282d86244f7a23
            >(),
            fee: 0xccccccccccccccccccccccccccccccc, // 
            tick_spacing: 354892,
            // TWAMM Extension
            // https://docs.ekubo.org/integration-guides/reference/contract-addresses
            extension: contract_address_const::<
                0x73ec792c33b52d5f96940c2860d512b3884f2127d25e023eb9d44a678e4b971
            >()
        },
        // sqrt_ratio_limit = (int("0x34b6ea79633d60552061b9c37d84a", 16) / 2**128)
        // ratio_limit = sqrt_ratio_limit**2
        // adjust for decimals: ratio_limit * 10**12
        sqrt_ratio_limit: 0x1000003f7f1380b76, // 
        skip_ahead: 0x0
    };

    let second_node = RouteNode {
        pool_key: PoolKey {
            token0: contract_address_const::<
                0x49d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7
            >(),
            token1: contract_address_const::<
                0x7ab0b8855a61f480b4423c46c32fa7c553f0aac3531bbddaa282d86244f7a23
            >(),
            fee: 0x20c49ba5e353f80000000000000000, // 0.05%
            tick_spacing: 354892,
            // TWAMM Extension
            // https://docs.ekubo.org/integration-guides/reference/contract-addresses
            extension: contract_address_const::<
                0x73ec792c33b52d5f96940c2860d512b3884f2127d25e023eb9d44a678e4b971
            >()
        },
        sqrt_ratio_limit: 0x7ea4d9526482a9577ead999cd4fa76f2ba8dfdca5b3f2f, // 
        skip_ahead: 0x0
    };

    let token_address = contract_address_const::<
        0x49d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7
    >();
    let amount: u128 = 0x2386f26fc10000; // 10000000000000000
    let token_amount = TokenAmount {
        token: token_address, amount: i129 { mag: amount, sign: false }
    };
    let token = IERC20Dispatcher { contract_address: token_address };

    // let router = IRouterDispatcher { contract_address: contract_address_const::<
    //     EKUBO_ROUTER_ADDRESS
    // >() };
    // let result = router.multihop_swap(array![first_node, second_node], token_amount);
    // assert(*result[0].amount0.mag == amount, 'first input');
    // assert(*result[1].amount0.mag == 0x2ab89317ae54c0, 'second input'); // 12024890918851776

    // We test a flash loan so the owner shouldn't have enough funds
    assert(token.balanceOf(test_address()) < amount.into(), 'owner has no funds');

    let mut spy = spy_events();
    let dispatcher = declare_and_deploy();
    assert(dispatcher.get_owner() == test_address(), 'owner is set');

    let route = array![first_node, second_node];
    dispatcher.multihop_swap(route, token_amount);
    spy
        .assert_emitted(
            @array![
                (
                    dispatcher.contract_address,
                    Arbitrage::Event::Arbitrage(
                        Arbitrage::Arbitrage {
                            recipient: test_address(),
                            profit: 0x731a0a7ed54c0, // 0x2ab89317ae54c0 - 0x2386f26fc10000
                            token: token_address,
                        }
                    )
                )
            ]
        );
}

