use snforge_std::{declare, spy_events, ContractClassTrait, test_address, EventSpyAssertionsTrait};
use ekubo::types::keys::{PoolKey};
use ekubo::types::i129::i129;
use ekubo::router_lite::{RouteNode, TokenAmount, Swap};
// `IArbitrageurDispatcher` and `IArbitrageurDispatcherTrait` are generated by compiler within the
// attribute macros `#[starknet::interface]` for `pub trait IArbitrageur<TContractState>`
// see also
// https://book.cairo-lang.org/ch13-02-anatomy-of-a-simple-contract.html#the-interface-the-contracts-blueprint
use ekubo_flash_loan::{Arbitrage, IArbitrageurDispatcher, IArbitrageurDispatcherTrait};
use starknet::{ContractAddress, contract_address_const};

fn deploy_contract(name: ByteArray) -> ContractAddress {
    let contract = declare(name).unwrap();
    let (contract_address, _) = contract.deploy(@ArrayTrait::new()).unwrap();
    contract_address
}


// https://docs.ekubo.org/integration-guides/reference/contract-addresses
const EKUBO_CORE_ADDRESS: felt252 =
    0x00000005dd3D2F4429AF886cD1a3b08289DBcEa99A294197E9eB43b0e0325b4b;


fn declare_and_deploy() -> IArbitrageurDispatcher {
    // First declare and deploy a contract
    // (the name of the contract is the contract module name)
    let contract = declare("Arbitrage").unwrap();
    // deploy function accepts a snap of an array of contract arguments serialized as felt252
    let (contract_address, _) = contract.deploy(@array![EKUBO_CORE_ADDRESS]).unwrap();

    // Create a Dispatcher object that will allow interacting with the deployed contract
    IArbitrageurDispatcher { contract_address }
}

#[test]
fn test_get_owner() {
    let dispatcher = declare_and_deploy();

    // Call a view function of the contract
    let owner = dispatcher.get_owner();
    // test_address function returns the address of the current test which is a contract itself
    assert(owner == test_address(), 'owner is set');
}

#[test]
fn test_creation_event() {
    // https://foundry-rs.github.io/starknet-foundry/testing/testing-events.html#asserting-emission-with-assert_emitted-method
    let mut spy = spy_events();

    let dispatcher = declare_and_deploy();

    spy
        .assert_emitted(
            @array![
                (
                    dispatcher.contract_address,
                    Arbitrage::Event::NewBot(Arbitrage::NewBot { owner: test_address() })
                )
            ]
        );
}

#[should_panic(expected: ('Unprofitable swap',))]
#[test]
#[fork("MAINNET_FORK")]
fn test_empty_swap() {
    let dispatcher = declare_and_deploy();

    dispatcher.multi_multihop_swap(array![]);
}

// test access
//

#[test]
#[fork("MAINNET_FORK_SWAP")]
fn test_profitable_opportunity() {
    // As a test input I took an arbitrage transaction from
    // https://medium.com/@maksim.ryndin/how-to-create-an-atomic-arbitrage-bot-in-starknet-part-2-the-foggy-desert-d3f28fad69c7
    // https://voyager.online/tx/0x724d7d0beae938fb2adee340d6aedfc69dc0bdc3c166cddc7f1ff33c6ecf4ac
    let route = array![
        RouteNode {
            pool_key: PoolKey {
                token0: contract_address_const::<
                    0x04718f5a0fc34cc1af16a1cdee98ffb20c31f5cd61d6ab07201858f4287c938d
                >(),
                token1: contract_address_const::<
                    0x53c91253bc9682c04929ca02ed00b3e423f6710d2ee7e0d5ebb06f3ecf368a8
                >(),
                fee: 0x068db8bac710cb4000000000000000, // 0.01%
                tick_spacing: 200,
                extension: contract_address_const::<0x0>()
            },
            sqrt_ratio_limit: 0xfffffc080ed7b4556f3528fe26840249f4b191ef6dff7928,
            skip_ahead: 0x0
        },
        RouteNode {
            pool_key: PoolKey {
                token0: contract_address_const::<
                    0x04718f5a0fc34cc1af16a1cdee98ffb20c31f5cd61d6ab07201858f4287c938d
                >(),
                token1: contract_address_const::<
                    0x049d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7
                >(),
                fee: 0x20c49ba5e353f80000000000000000, // 0.05%
                tick_spacing: 1000,
                extension: contract_address_const::<0x0>()
            },
            sqrt_ratio_limit: 0x01000003f7f1380b75,
            skip_ahead: 0x0
        },
        RouteNode {
            pool_key: PoolKey {
                token0: contract_address_const::<
                    0x049d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7
                >(),
                token1: contract_address_const::<
                    0x053c91253bc9682c04929ca02ed00b3e423f6710d2ee7e0d5ebb06f3ecf368a8
                >(),
                fee: 0x20c49ba5e353f80000000000000000, // 0.05%
                tick_spacing: 1000,
                extension: contract_address_const::<0x0>()
            },
            sqrt_ratio_limit: 0x01000003f7f1380b75,
            skip_ahead: 0x0
        }
    ];

    let token_amount = TokenAmount {
        token: contract_address_const::<
            0x053c91253bc9682c04929ca02ed00b3e423f6710d2ee7e0d5ebb06f3ecf368a8
        >(),
        amount: i129 { mag: 0x2625dc40, sign: false }
    };

    let mut spy = spy_events();
    let dispatcher = declare_and_deploy();

    dispatcher.multihop_swap(route, token_amount);
}

